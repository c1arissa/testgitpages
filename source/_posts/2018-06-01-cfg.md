---
layout: post
title:  "Control-Flow Integrity and Microsoft’s Control Flow Guard (CFG)"
author: Clarissa Podell
date:   2018-06-01 13:46:52
comments: false
categories: windows exploit
tags:
   - windows
   - exploit
---

## Intro
Exploit development and exploit mitigation techniques are among my favorite topics in cybersecurity.  I first came across exploit mitigations while playing online wargames.  At first, like many others I’m sure, I found these defenses frustrating as my normal late 90’s-style techniques failed.  However, after learning about more advanced exploitation techniques, I have now come to appreciate exploit mitigations and equally appreciate the techniques to bypass them.  The ingenuity and sophistication of exploits that outsmart defenses is fascinating.  What’s more, I find the techniques to bypass these defenses exhilarating – the ingenuity of outsmarting defenses developed by the efforts of very intelligent defense teams.

So, when it came time to select a topic for our Capstone research project, I convinced my team of 3 other students to agree with the topic of Bypassing Control Flow Integrity.  We chose to focus on Microsoft’s CFI implementation called Control-Flow Guard (CFG) mostly because of its popularity and relevancy to the current security landscape.

In this post, I will provide a brief summary of CFG internals that I [accumulated/compiled during my research] learned during this research.  This is similar to a cheatsheet that I used during my research.  
Most of this information was acquired while working on a research project exploring techniques to bypass CFG.  

## Control-Flow Integrity (CFI)
Control-Flow Integrity (CFI) is an exploit mitigation technique that has existed for over a decade (mostly in academia) to defend against a class of exploit techniques called control-flow hijacking attacks.  In these attacks, a user attempts to divert normal program execution to run arbitrary instructions with the same privileges as the program.  CFI promises to limit program execution to valid traces only based on a pre-determined Control-Flow Graph of the programmer’s intended design.  Even in the presence of a memory-corruption vulnerability, this makes it more difficult for attackers to redirect execution maliciously.  Researchers have found it difficult to implement CFI because of concerns varying from additional overhead and computing costs, compatibility issues, and the difficulty of creating an accurate Control-Flow Graph.  Only recently have we seen widespread adoption with the deployment of production-ready technologies in late 2014 from Microsoft and LLVM/Clang.

## Control-Flow Guard Internals
A compiler-based security mechanism that combats exploitation of memory corruption vulnerabilities commonly found in programs written in unsafe programming lanuages such as C and C++.  Extra runtime security checks can detect attempts to alter the intended flow of code, known as a control-flow hijack attack.  Makes it much harder for exploits to execute arbitrary code through memory corruption vulnerabilities such as buffer overflows.
A combination of compile and run-time support from CFG implements control flow integrity that tightly restricts where indirect call instructions can execute.

{% highlight c %}
//  test-cfg.c  
#include <stdio.h>
void foo() {
    printf("Inside indirect call.\n");
}
void main(int argc, char** argv) {
    void (*fptr)() = foo;
    (*fptr)();     // Indirect call
}
{% endhighlight %}

The above code blah blah.

### Enabling CFG

MSVC’s `/guard:cf` switch enables compiler generation of Control Flow Guard security checks.  When enabled, the compiler analyzes control flow for valid indirect call targets at compile time, and then inserts code to verify the targets at runtime [[1]](https://msdn.microsoft.com/en-us/library/dn919635.aspx). The valid call sites identified by the compiler are stored in extra structures in the headers of your binaries and used at runtime to validate destination locations of indirect calls.

In a Visual Studio Native Tools command prompt (usually comes installed with the Visual Studio IDE), the following command compiles and links the source code with CFG protection:

`C:\test> cl /Zi /guard:cf test-cfg.c`

where `cl.exe` is the name of the compiler / linker program, `/Zi` enables debugging information, `/guard:cf` enables CFG, and `test-cfg.c` is the name of the source code file.

### Checking if CFG is enabled

{% highlight console %}
C:\test> cl /Zi /guard:cf test-cfg.c
Microsoft (R) C/C++ Optimizing Compiler Version 19.00.24215.1 for x86
Copyright (C) Microsoft Corporation.  All rights reserved.

test-cfg.c
Microsoft (R) Incremental Linker Version 14.00.24215.1
Copyright (C) Microsoft Corporation.  All rights reserved.

/out:test-cfg.exe
/debug
/guard:cf
test-cfg.obj
{% endhighlight %}


```
C:\test> dumpbin /headers /loadconfig test-cfg.exe
Microsoft (R) COFF/PE Dumper Version 14.00.24215.1
Copyright (C) Microsoft Corporation.  All rights reserved.


Dump of file test-cfg.exe

PE signature found

File Type: EXECUTABLE IMAGE

FILE HEADER VALUES
...

OPTIONAL HEADER VALUES
             10B magic # (PE32)
           14.00 linker version
           5BA00 size of code
           10A00 size of initialized data
               0 size of uninitialized data
            2260 entry point (00402260) @ILT+4688(_mainCRTStartup)
            1000 base of code
           5D000 base of data
          400000 image base (00400000 to 00470FFF)
            1000 section alignment
             200 file alignment
            6.00 operating system version
            0.00 image version
            6.00 subsystem version
               0 Win32 version
           71000 size of image
             400 size of headers
               0 checksum
               3 subsystem (Windows CUI)
            C140 DLL characteristics
                   Dynamic base
                   NX compatible
                   Control Flow Guard
                   Terminal Server Aware
          100000 size of stack reserve
            1000 size of stack commit
          100000 size of heap reserve
            1000 size of heap commit

  Section contains the following load config:

            0000005C size
                   0 time date stamp
                0.00 Version
                   0 GlobalFlags Clear
                   0 GlobalFlags Set
                   0 Critical Section Default Timeout
                   0 Decommit Free Block Threshold
                   0 Decommit Total Free Threshold
            00000000 Lock Prefix Table
                   0 Maximum Allocation Size
                   0 Virtual Memory Threshold
                   0 Process Heap Flags
                   0 Process Affinity Mask
                   0 CSD Version
                0000 Dependent Load Flag
            00000000 Edit List
            00468020 Security Cookie
            00466AD0 Safe Exception Handler Table
                   3 Safe Exception Handler Count
            0046D000 Guard CF address of check-function pointer
            00000000 Guard CF address of dispatch-function pointer
            0046C000 Guard CF function table
                  52 Guard CF function count
            10010500 Guard Flags
                       CF Instrumented
                       FID table present
                       Long jump target table present

    Guard CF Function Table

          Address
          --------
          00401090  @ILT+128(___acrt_locale_initialize_numeric)
          004012D0  @ILT+704(___acrt_uninitialize_lowio)
          00401540  @ILT+1328(___acrt_uninitialize_stdio)
          004015B0  @ILT+1440(___acrt_initialize_command_line)
          004015E0  @ILT+1488(?getLastChar@pDNameNode@@UBEDXZ)
          00401640  @ILT+1584(___acrt_initialize_multibyte)
          00401690  @ILT+1664(?getString@DNameStatusNode@@UBEPADPAD0@Z)
          00402260  @ILT+4688(_mainCRTStartup)
          00402820  @ILT+6160(___vcrt_freefls@4)
          00402A20  @ILT+6672(?getString@pairNode@@UBEPADPAD0@Z)
          00402EF0  @ILT+7904(___dcrt_terminate_console_output)
          00402F40  @ILT+7984(___acrt_uninitialize_locks)
          00403710  @ILT+9984(___acrt_uninitialize_command_line)
          004037A0  @ILT+10128(??_Etype_info@@UAEPAXI@Z)
          00403A80  @ILT+10864(?getString@charNode@@UBEPADPAD0@Z)
          00404320  @ILT+13072(?getString@pcharNode@@UBEPADPAD0@Z)
          00404560  @ILT+13648(?getLastChar@pcharNode@@UBEDXZ)
          00404810  @ILT+14336(_foo)
          00404890  @ILT+14464(___scrt_unhandled_exception_filter@4)
          004048D0  @ILT+14528(_abort)
          00404B30  @ILT+15136(?getString@pDNameNode@@UBEPADPAD0@Z)
          00404E80  @ILT+15984(?getLastChar@charNode@@UBEDXZ)
          00405570  @ILT+17760(__RTC_Terminate)
          004055C0  @ILT+17840(___acrt_initialize_sse2)
          004055D0  @ILT+17856(___acrt_locale_initialize_ctype)
          00405940  @ILT+18736(__matherr)
          004065F0  @ILT+21984(___acrt_initialize_heap)
          00406600  @ILT+22000(___acrt_locale_initialize_monetary)
          00406670  @ILT+22112(___acrt_initialize_locks)
          00406730  @ILT+22304(___acrt_invoke_user_matherr)
          00406790  @ILT+22400(___acrt_initialize_lowio)
          00406B60  @ILT+23376(??_Etype_info@@UAEPAXI@Z)
          004074B0  @ILT+25760(?length@pairNode@@UBEHXZ)
          00407950  @ILT+26944(@_guard_check_icall_nop@4)
          00407F50  @ILT+28480(?getLastChar@pairNode@@UBEDXZ)
          004080F0  @ILT+28896(?getLastChar@DNameStatusNode@@UBEDXZ)
          00408300  @ILT+29424(___acrt_initialize_stdio)
          00408770  @ILT+30560(?length@pDNameNode@@UBEHXZ)
          00408A00  @ILT+31216(___acrt_uninitialize_ptd)
          00408AB0  @ILT+31392(?length@DNameStatusNode@@UBEHXZ)
          00408B00  @ILT+31472(__purecall)
          00408C50  @ILT+31808(___acrt_uninitialize_locale)
          00408DB0  @ILT+32160(___acrt_initialize_winapi_thunks)
          00408DF0  @ILT+32224(___acrt_locale_initialize_time)
          004091B0  @ILT+33184(?length@charNode@@UBEHXZ)
          00409440  @ILT+33840(___acrt_uninitialize_heap)

```


### Sources
[1]. [/guard (Enable Control Flow Guard)](https://msdn.microsoft.com/en-us/library/dn919635.aspx)
