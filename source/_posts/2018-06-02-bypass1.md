---
layout: post
title:  "Modern Windows Exploitation: Bypassing Stack Cookies (/GS)"
author: Clarissa Podell
date:   2018-06-02
comments: false
categories: windows exploit
tags:
   - windows
   - exploit
---

## Contents
1. Introduction
2. Reversing Microsoft Visual Studio Security Cookie

The purpose of this post is to show exploitation on a modern Windows OS.  I was inspired to make this blog post while doing research for my senior capstone project on Windows mitigation techniques.  I realized there was a lack of up-to-date information on this subject so I thought it was a good idea to share some of the tools and methods I used in bypassing basic exploit mitigations to hopefully help other people in the same situation.

I was inspired to make this blog post after realizing/when I realized (the lack of information while) there was a lack of up-to-date information on this subject while doing research for my senior capstone project on Windows mitigation techniques.

There are a number of mitigations built-in to all newer versions of Windows including:
* Address Space Layout Randomization (ASLR) `/DYNAMICBASE` linker switch
* Data Execution Prevention (DEP) `/NXCOMPAT` linker switch
* Stack Cookies `/GS` compiler switch
* Structured Exception Handling (SEH) SEHOP and Safeseh `/SAFESEH` linker switch
* Control-Flow Guard (CFG) `/guard` compiler/linker switch

According to Microsoft docs, /GS (Buffer Security Check) "detects some buffer overruns that overwrite a function's return address, exception handler address, or certain types of parameters".

In this post, I demonstrate how to bypass Stack Cookie protection in Windows 10 using the below C source code `vuln.c`.  This code contains two simple yet realistic vulnerabilities which create the perfect conditions to launch this type of attack.  The first vulnerability appears in `leak()` that prints arbitrary addresses from an uninitialized array and the second is a stack-based buffer overflow vulnerability that allows an attacker to corrupt and hijack the return address of `vuln()`.  


{% highlight c %}
#include <stdio.h>
#include <string.h>
#define STDIN 0

void leak(){
	char buf[64];
	int nr, i;
	unsigned int *value;
	value = (unsigned int*)buf;
	if( scanf("%d", &nr) == 0 ) {
		while( fflush( stdin ) != 0)
			;
	}
	for(i=0; i < nr; i++)
		printf("0x%08x ", value[i]);
}

void vuln() {
	char buf[1024];
	read(STDIN, buf, 2048);
}

void main(int argc, char* argv[]) {
	setbuf(stdout, NULL);
	printf("echo> ");
	leak();
	printf("\nread> ");
	vuln();
	printf("\ndone.\n");
}
{% endhighlight %}
<figcaption>Figure: <code>vuln.c</code> source code</figcaption>

The line `read(STDIN, buf, 2048)` in `vuln()` will overflow if more than 1024 bytes are read into character array `buf[1024]`.  Without proper bounds checking in the `read()` library function, we can write past `buf`'s allocated region in memory and corrupt the adjacent stack contents.  This potentially overwrites important control values stored on the stack.

The C library function `read()` does not enforce buffer size restrictions.

We can leverage this vulnerability in our exploit to overwrite the saved return address on the stack with an address that points to an area in memory that we control.  The address that contains our malicious payload will be obtained from the memory leak in `leak()` to guarantee a stable address despite ASLR.

## Setup

Everything here was run on my personal laptop (Windows 10 64-bit host OS version 1709 build 16299.492).  All source code was compiled with Visual Studio 2015 Build Tools and the x86 Native Tools Command Prompt for x86 output files.  It's my personal preference to write code in a text editor and then compile in a terminal, but the VS IDE can be easily substituted.

First, the code is compiled with the below command in one of the VS command prompts:

```console
C:\tmp> cl /Zi vuln.c /link /NXCOMPAT:NO
Microsoft (R) C/C++ Optimizing Compiler Version 19.00.24215.1 for x86
Copyright (C) Microsoft Corporation.  All rights reserved.

vuln.c
Microsoft (R) Incremental Linker Version 14.00.24215.1
Copyright (C) Microsoft Corporation.  All rights reserved.

/out:vuln.exe
/debug
/NXCOMPAT:NO
vuln.obj
```

This produces `vuln.exe`, a 32-bit PE file format executable with debugging information (`/Zi`).  Note that `/NXCOMPAT:NO` disables Data Execution Prevention (DEP) in the linker.  In this post I focus on bypassing ASLR and Stack Cookies.  My next post will build on the exploit in this post and show how to bypass DEP.  Because Stack Cookie (`/GS`) protection is enabled by default in Windows, we do not need to explicitly pass any options to the compiler.

## Reversing MSVC Security Cookie /GS

Before strategizing a bypass method, we need to get a better idea on how the cookie is implemented in our program.  Loading the program in a debugger like Windbg demonstrates some cookie behavior.  The following command in Windbg shows all symbols (variables, function names, etc.) related to the cookie.

Stack cookie protection debugging & demonstration
In order to demonstrate some stack cookie behaviour, we’ll use a simple piece of code above.

### Initialize the Security Cookie

The security cookie is initialized on entry to an EXE or DLL.  This routine is named `__security_init_cookie`.

right before the saved EBP and EIP.
[buffer][cookie][saved EBP][saved EIP]

The implementation of stack cookies vary by compiler and OS.  MS Visual Studio uses a Pseudorandom XOR Cookie.

```nasm
0:000> x vuln!*cookie*
*** WARNING: Unable to verify checksum for vuln.exe
0043e02c          vuln!__security_cookie_complement = 0x44bf19b1
0043e030          vuln!__security_cookie = 0x28d8dc5e
003d75b8          vuln!__security_check_cookie (unsigned int)
003d88b0          vuln!ValidateLocalCookies (struct _EH4_SCOPETABLE *, char *)
003d8181          vuln!__security_init_cookie (void)
```

Disassembling the initialization function /routine in Windbg reveals some important implementation details / internals.  The entire routine is pretty long, so I only show a small section of it below:

```nasm
0:000> uF vuln!__security_init_cookie
...
vuln!__security_init_cookie+0x30 [f:\dd\vctools\crt\vcstartup\src\gs\gs_support.c @ 108]:
003d81b1 8d45f4          lea     eax,[ebp-0Ch]
003d81b4 50              push    eax
003d81b5 ff1520104400    call    dword ptr [vuln!_imp__GetSystemTimeAsFileTime (00441020)]
003d81bb 8b45f8          mov     eax,dword ptr [ebp-8]
003d81be 3345f4          xor     eax,dword ptr [ebp-0Ch]
003d81c1 8945fc          mov     dword ptr [ebp-4],eax
003d81c4 ff151c104400    call    dword ptr [vuln!_imp__GetCurrentThreadId (0044101c)]
003d81ca 3145fc          xor     dword ptr [ebp-4],eax
003d81cd ff1518104400    call    dword ptr [vuln!_imp__GetCurrentProcessId (00441018)]
003d81d3 3145fc          xor     dword ptr [ebp-4],eax
003d81d6 8d45ec          lea     eax,[ebp-14h]
003d81d9 50              push    eax
003d81da ff1514104400    call    dword ptr [vuln!_imp__QueryPerformanceCounter (00441014)]
```

The cookie is initialized using a combination of routines: `GetSystemTimeAsFileTime`, `GetCurrentThreadId`, `GetCurrentProcessId`, and `QueryPerformanceCounter`.  This ensures the value will be random and difficult to guess or reproduce.  While the first three functions are simple enough to guess,

### Prologue and Epilogue

When `/GS` is enforced, a program generated master security cookie (4 bytes (dword), unsigned int) is initialized at startup and saved in the data section of memory.  The compiler inserts code in each vulnerable function to enforce the validity of the cookie before processing the return address at runtime.  A "vulnerable" function contains a string buffer over 5 bytes long or allocates memory on the stack.  This prevents abusing stack-based buffer overflows.

Lately, I've been using a lot of Windbg.  To view the disassembly of a function, use `uf [function_name]` where function_name is represented in the form `module_name!function_name`.  In this case: `uf vuln!vuln` (both module and function names are `vuln`).

Using the disassembly of `vuln()` as an example, I'll break down the prologue and epilogue of a function compiled with this mitigation.

In the function prologue, three lines of assembly code are inserted by the compiler.  Each line is commented below.  After the stack allocates space for local variables, the program cookie in `vuln!__security_cookie` is copied to the stack in register `eax`.
The result of the cookie in `eax` XOR'd with the address of `ebp` is then saved in `[ebp-4]`.  Next, the value of the cookie is XOR'd with the address of ebp and then saved in `[ebp-4]`.  This location is between the local variables and the return address.

a copy of the program cookie in is stored in `eax`.
Next, logical xor of the cookie with the address of `ebp` is stored on the stack after local variables and right before the saved EBP and EIP, directly below the return address

```nasm
0:000> uf vuln!vuln
vuln!vuln [c:\tmp\vuln.c @ 18]:
003d73a0 55              push    ebp
003d73a1 8bec            mov     ebp,esp
003d73a3 81ec04040000    sub     esp,404h
003d73a9 a130e04300      mov     eax,dword ptr [vuln!__security_cookie (0043e030)] ; GS support compiler-added
003d73ae 33c5            xor     eax,ebp   ; GS support
003d73b0 8945fc          mov     dword ptr [ebp-4],eax  ; GS support
...cut...
```

Likewise, in the function epilogue, assembly code is inserted right before the function returns.  The XOR'd value calculated in the prologue is moved out of the location in `[ebp-4]` and into the register `ecx`.  A second XOR is performed on the value in `ecx` and the address in `ebp`, revealing the original security cookie, and a call to `vuln!ILT+30336(__security_check_cookie)` is made.

get stack’s copy of the cookie, perform the xor again, jump to the routine to verify the cookie.

The security check compares the value in `ecx` with the program-wide master cookie in `vuln!__security_cookie` and either continues execution normally or terminates early if corruption is detected.


At this point, the compiler can detect a buffer overflow attack.  Since the vulnerable call to `read()` will result in overwriting the stack cookie in the location `[ebp-4]`, ecx will contain the incorrect value and the check will fail.

In short : a security cookie is added to the stack and is compared again before the function returns

```nasm
003d73c9 8b4dfc          mov     ecx,dword ptr [ebp-4] ; GS support
003d73cc 33cd            xor     ecx,ebp  ; GS support
003d73ce e83ac1ffff      call    vuln!ILT+9480(__security_check_cookie (003d350d) ; GS support
003d73d3 8be5            mov     esp,ebp
003d73d5 5d              pop     ebp
003d73d6 c3              ret
```

Taking a closer look at the `__security_check_cookie` function below,

```nasm
0:000> uf vuln!__security_check_cookie
vuln!__security_check_cookie:
003d75b8 3b0d30e04300    cmp     ecx,dword ptr [vuln!__security_cookie (0043e030)]
003d75be f27502          bnd jne vuln!__security_check_cookie+0xb (003d75c3)  Branch

vuln!__security_check_cookie+0x9:
003d75c1 f2c3            bnd ret  Branch

vuln!__security_check_cookie+0xb:
003d75c3 f2e99fc3ffff    bnd jmp vuln!ILT+10595(___report_gsfailure) (003d3968)  Branch

vuln!__security_check_cookie:
003d75b8 3b0d30e04300    cmp     ecx,dword ptr [vuln!__security_cookie (0043e030)]
003d75be f27502          bnd jne vuln!__security_check_cookie+0xb (003d75c3)
003d75c1 f2c3            bnd ret
003d75c3 f2e99fc3ffff    bnd jmp vuln!ILT+10595(___report_gsfailure) (003d3968)
```

Below is a visual representation of the runtime stack labeled with offsets to the base pointer `ebp`.  To the right is what happens in memory when we fill the contents of `buf` and overwrite the adjacent area.  

To the right demonstrates what happens in memory during a typical buffer overflow attack that attempts to overwrite the saved EIP.  The overwrite direction is downwards starting at `buf` and continuing towards the main stack frame.

attacker-controlled data is then written starting at that address, overwriting ConvertPathMacro’s stack frame data:

<img class="img-fancy" src="{{ site.baseurl }}/images/stack.PNG">

As illustrated, the attempt to overwrite the saved EIP also overwrites the cookie.  When the security check function runs, it will notice that the cookie has been changed and terminate execution.

So, there are a few ways we can bypass the security check function which compares the program cookie with the value in ebp-4:

1. Write the correct value of the cookie in the payload at location ebp-4
2. Brute force the Cookie

## Stack cookie /GS bypass methods

Now that we know a little about how GS-protection is implemented, we can come up with a game plan to overcome it.  I typically do this by researching limitations and vulnerabilities in the mechanism.

A successful exploit is dependent on passing or avoiding the security check.  To pass the check, by the end of the function, the copy of the cookie on the stack matches the master cookie.  Because the master cookie is stored in the program's .data section and this memory is marked read-only, changing the value of the master is out of the question.  

One of the easier methods to overcome GS-protection requires guessing, calculating, or somehow retrieving the value of the program cookie and overwriting the (copy on the stack) cookie with the same value in your buffer/replacing the cookie with the correct value.

Alternatively, There are Other/previous bypass methods that rely on avoiding the security check by gaining control before the security cookie check executes.  Another documented method involves overwriting an Exception Handler registration structure (next SEH + Pointer to SE Handler) to trigger an exception before the cookie is checked, the stack based overflow could be executed (= SEH based exploit) despite the stack cookie.

Summary of bypass methods (based on Corelan's excellent article)

1. Bypass using Exception Handling
So, we can defeat stack protection by triggering an exception before the cookie is checked during the epilogue (or we can try to overwrite other data (parameters that are pushed onto the stack to the vulnerable function), which is referenced before the cookie check is performed.), and then deal with possible SEH protection mechanisms, if any… Of course, this second technique only works if the code is written to actually reference this data. You can try to abuse this by writing beyond the end of the stack.

The key in this scenario is that you need to overwrite far enough, and that there is an application specific exception registered (which gets overwritten). If you can control the exception handler address (in the Exception_Registration structure), then you can try to overwrite the pointer with an address that sits outside the address range of a loaded module. After all, SEH records on the stack are not protected by GS… you only have to bypass SafeSEH.

2. Bypass by replacing cookie on stack and in .data section
Another technique to bypass stack cookie protection is by replacing this authoritative cookie value in the .data section of the module (which is writeable, otherwise the applicaiton would not be able to calculate a new cookie and store it at runtime), and replace the cookie in the stack with the same value. This technique is only possible if you have the ability to write anything at any location. (4 byte artbitrary write) – access violations that state something like the instruction below indicate a possible 4 byte arbitrary write :
mov dword ptr[reg1], reg2
(In order to make this work, you obviously need to be able to control the contents of reg1 and reg2). reg1 should then contain the memory location where you want to write, and reg2 should contain the value you want to write at that address.

3. Bypass because not all buffers are protected
Another exploit opportunity arises when the vulnerable code does not contains string buffers (because there will not be a stack cookie then) This is also valid for arrays of integers or pointers.
[buffer][cookie][EH record][saved ebp][saved eip][arguments ]
Example : If the “arguments” don’t contain pointers or string buffers, then you may be able to overwrite these arguments and take advantage of the fact that the functions are not GS protected.

4. Bypass by overwriting stack data in functions up the stack
When pointers to objects or structures are passed to functions, and these objects or structures resided on the stack of their callers (parent function), then this could lead to GS cookie bypass. (overwrite object and vtable pointer. If you point this pointer to a fake vtable, you can redirect the virtual function call and execute your evil code)

5. Bypass because you can guess/calculate the cookie
Reducing the Effective Entropy of GS Cookies

6. Bypass because the cookie is static
Finally, if the cookie value appears to be the same/static every time, then you can simply put this value on the stack during the overwrite.


In the remainder of this post I will model an exploit for method 2 bypassing by replacing cookie on stack. simply put this value on the stack during the overwrite

## Exploit Development

By leveraging the memory leak vulnerability in `leak()`, we can overwrite the stack cookie with the correct value.  There are two things to consider when constructing a payload that replaces the cookie with the correct value.  First we need to ensure proper placement of [ebp-4] in our payload so we overwrite the cookie at the correct location.  As previously discussed, the value in [ebp-4] is compared against the program cookie in the epilogue check function.  Our exploit must be aligned in the following way to ensure proper alignment with the runtime stack:

First we need to ensure proper placement of the cookie in our payload so it aligns to the correct location [ebp-4] in the runtime stack.

```console
[       buf       ][  ebp-4  ][   ebp   ][   eip   ][  nops  ][  shellcode  ]
```

```console
----------------- -------------------
||             ||                   |
||  buf        ||  (1024 bytes)     |
||             ||                   |
-----------------                   |
||  ebp-4      ||                   |
-----------------                   |
||  ebp        ||                   |
-----------------                   |===> 2048 bytes (total)
||  eip        ||                   |
-----------------                   |
||  nops       ||                   |
-----------------                   |
||  shellcode  ||                   |
----------------- -------------------
```

Where `buf` contains 1024 bytes and `ebp-4`, `ebp`, `eip` (saved return address) each contain 4 bytes.  The number of bytes for `nops` and `shellcode` is arbitrary up to the `read()` limit of 1024 bytes (reads 2048 bytes total).

Second, we need the correct value to write in ebp-4.  One way to do this is by setting a program breakpoint on the fourth line of the function prologue when the program generated security cookie is copied into eax: `010873a9 a130e00e01   mov eax,dword ptr [vuln!__security_cookie (010ee030)]`.  When the program hits the breakpoint, we can directly access the cookie's value by analyzing the memory at the cookie's address `0x0133c030`.

With the program loaded in Windbg, we can easily access the cookie's value by analyzing the memory at the cookie's address.  I show one way to do this below using the symbol `vuln!__security_cookie`.

There are a number of ways to view the cookie's value in Windbg.  After opening the executable, the cookie can be directly accessed by analyzing the memory at the cookie's address `0x0133c030`.

```nasm
0:000> dd vuln!__security_cookie l4
010ee030  3b6f1f8b 00000000 ffffffff 00000001
```

Next, we need the value that we will be writing to [ebp-4].  We  reverse engineered the value of the cookie back to the fourth line of the function prologue where the program generated security cookie was moved into eax.  Opening the vulnerable program in a debugger and setting a breakpoint on this line, we can directly access the cookie's value by analyzing the memory at the cookie's address `0x0133c030`.

```nasm
0:000> bu 010873a9
0:000> g
Breakpoint 0 hit
eax=00000007 ebx=00cf8000 ecx=010921b4 edx=00000030 esi=010efe14 edi=010efe18
eip=010873a9 esp=00eff714 ebp=00effb18 iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000206
vuln!vuln+0x9:
010873a9 a130e00e01      mov     eax,dword ptr [vuln!__security_cookie (010ee030)] ds:002b:010ee030=53306582

0:000> dd 010ee030 l1
010ee030  53306582
```

\begin{lstlisting}[language=]
0:000> dd 0133c030 L1
0133c030  876ad73d
\end{lstlisting}

This address can be obtained from the symbol in the disassembly output \\ \texttt{minvuln!\_\_security\_cookie (0133c030)} or from the Load Config section of the PE header.  We can see that the stack cookie's value is \texttt{0x876ad73d} in the above WinDbg output.  Next, the value will be XOR'd with ebp and stored in [ebp-4].  We use the debugger again to show the address of our ebp register.  

\begin{lstlisting}[language=]
0:000> dd ebp L1
0096faa8  0096fab0
\end{lstlisting}

The ebp register is at address \texttt{0x0096faa8}.  We complete the algorithm by performing the following computation.

\[\mathtt{0x876ad73d}\ \oplus\ \mathtt{0x0096faa8}\]

The result \texttt{0x87fc2d95} is the value saved in location [ebp-4] during the function prologue routine.  We will use this value in our exploit to overwrite the stack at location [ebp-4] with the correct value.

To prove this will circumvent the security cookie check in the function epilogue, we show that the result of the XOR operation between the value in [ebp-4] and the address of ebp is equal to \texttt{0x876ad73d}, the program generated cookie.

\[\mathtt{0x87fc2d95}\ \oplus\ \mathtt{0x0096faa8}\]

This computation results in the value \texttt{0x876ad73d} which is equal to the program cookie.  Therefore, we prove that we can use this method to bypass stack cookie (GS) mitigation.

Leveraging our memory leak vulnerability that prints arbitrary addresses, we notice that the value needed to overwrite [ebp-4] (in the above example case \texttt{0x87fc2d95}) is located at the 17th address in our leaked output.  Using the Python exploit from stage 1, we are able to capture this value from the program output and use it as input to our payload.   

\paragraph{Results.}
Again, we have a fully working exploit that executes our arbitrary shellcode.  With some additional work, we are still able to use our exploit from Stage 1 to overwrite the return address of \texttt{vulnFun()} and redirect program behavior arbitrarily.  Using the Stack Cookie bypass technique described above, we successfully overwrote the stack with the correct security cookie to pass the check and execute our shellcode completely undetected.   

Based on these results and in the presence of a memory leak vulnerability, we can say that Stack Cookie protection does not strengthen or influence CFGuard in any noticeable way.



## Sources:
1. [GS cookie protection - effectiveness and limitations](https://blogs.technet.microsoft.com/srd/2009/03/16/gs-cookie-protection-effectiveness-and-limitations/)
2. [Exploit Writing Tutorial Part 6 by Corelan Team](https://www.corelan.be/index.php/2009/09/21/exploit-writing-tutorial-part-6-bypassing-stack-cookies-safeseh-hw-dep-and-aslr/)
3. [/GS (Buffer Security Check)](https://msdn.microsoft.com/en-us/library/8dbf701c.aspx)
